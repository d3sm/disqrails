<!DOCTYPE html>
<html>
  <head>
    <title><%= content_for(:title) || "Hor" %></title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="application-name" content="Hor">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="giphy-api-key" content="<%= giphy_api_key %>">
    <%= csrf_meta_tags %>
    <%= csp_meta_tag %>

    <%= yield :head %>

    <link rel="icon" href="/icon.png" type="image/png">
    <link rel="icon" href="/icon.svg" type="image/svg+xml">
    <link rel="apple-touch-icon" href="/icon.png">

    <%= stylesheet_link_tag :application, "data-turbo-track": "reload" %>
    <%= javascript_importmap_tags %>
  </head>

  <body>
    <div class="bg-grain"></div>
    <main class="shell">
      <header class="topbar">
        <button type="button" id="theme-toggle" class="theme-toggle" aria-expanded="false">theme [*]</button>
      </header>

      <section class="theme-lab-panel" id="theme-lab-panel" hidden>
        <p class="page-subtitle">Hex editor (Catppuccin defaults).</p>
        <div class="theme-grid" id="theme-grid"></div>
        <div class="theme-actions">
          <button type="button" id="theme-apply">Apply Theme</button>
          <button type="button" id="theme-reset">Reset to Catppuccin</button>
        </div>
        <p class="theme-status" id="theme-status"></p>
      </section>

      <% flash.each do |type, message| %>
        <p class="flash flash-<%= type %>"><%= message %></p>
      <% end %>

      <%= yield %>
    </main>
    <script type="module">
      (() => {
        let giphyFetchFactoryPromise;
        const STORAGE_KEY = "hor:vim-theme-vars:v1";
        const GIPHY_CACHE_KEY = "hor:giphy-fallback-cache:v1";
        const GIPHY_CACHE_TTL_MS = 1000 * 60 * 60 * 24 * 7;
        const grid = document.getElementById("theme-grid");
        const applyBtn = document.getElementById("theme-apply");
        const resetBtn = document.getElementById("theme-reset");
        const status = document.getElementById("theme-status");
        const toggleBtn = document.getElementById("theme-toggle");
        const panel = document.getElementById("theme-lab-panel");
        if (!grid || !applyBtn || !resetBtn || !status || !toggleBtn || !panel) return;

        const root = document.documentElement;
        const themeConfig = [
          { key: "--bg", label: "Background", default: "#1e1e2e" },
          { key: "--surface", label: "Surface", default: "#181825" },
          { key: "--surface-2", label: "Surface 2", default: "#313244" },
          { key: "--line", label: "Line", default: "#45475a" },
          { key: "--text", label: "Text", default: "#cdd6f4" },
          { key: "--muted", label: "Muted", default: "#a6adc8" },
          { key: "--accent", label: "Accent", default: "#89b4fa" },
          { key: "--danger-bg", label: "Danger BG", default: "#3a1d2e" },
          { key: "--danger-line", label: "Danger Line", default: "#f38ba8" },
          { key: "--danger-text", label: "Danger Text", default: "#f38ba8" }
        ];
        const themeVarNames = themeConfig.map((x) => x.key);
        const inputByKey = {};

        const normalizeColor = (value) => {
          if (!value) return null;
          const v = String(value).trim().replace(/^["']|["']$/g, "");
          if (/^#([0-9a-f]{3}|[0-9a-f]{6})$/i.test(v)) return v;
          return null;
        };

        const buildThemeInputs = () => {
          themeConfig.forEach((item) => {
            const wrap = document.createElement("label");
            wrap.className = "theme-field";

            const caption = document.createElement("span");
            caption.textContent = item.label;
            wrap.appendChild(caption);

            const input = document.createElement("input");
            input.type = "text";
            input.value = item.default;
            input.placeholder = "#RRGGBB";
            input.dataset.themeVar = item.key;
            wrap.appendChild(input);

            inputByKey[item.key] = input;
            grid.appendChild(wrap);
          });
        };

        const readThemeInputs = () => {
          const vars = {};
          Object.entries(inputByKey).forEach(([key, input]) => {
            const value = normalizeColor(input.value);
            if (value) vars[key] = value;
          });
          return vars;
        };

        const fillThemeInputs = (vars) => {
          themeConfig.forEach((item) => {
            const input = inputByKey[item.key];
            if (!input) return;
            input.value = vars[item.key] || item.default;
          });
        };

        const applyVars = (vars) => {
          themeVarNames.forEach((name) => root.style.removeProperty(name));
          Object.entries(vars).forEach(([name, value]) => {
            if (themeVarNames.includes(name) && normalizeColor(value)) {
              root.style.setProperty(name, value);
            }
          });
        };

        buildThemeInputs();
        const savedRaw = localStorage.getItem(STORAGE_KEY);
        if (savedRaw) {
          try {
            const saved = JSON.parse(savedRaw);
            if (saved && typeof saved === "object") {
              fillThemeInputs(saved);
              applyVars(saved);
              status.textContent = "Loaded saved theme.";
            }
          } catch (_) {
            localStorage.removeItem(STORAGE_KEY);
          }
        } else {
          fillThemeInputs({});
        }

        applyBtn.addEventListener("click", () => {
          const parsed = readThemeInputs();
          if (Object.keys(parsed).length === 0) {
            status.textContent = "Add valid hex values like #89b4fa.";
            return;
          }
          applyVars(parsed);
          localStorage.setItem(STORAGE_KEY, JSON.stringify(parsed));
          status.textContent = `Applied ${Object.keys(parsed).length} theme variables.`;
        });

        resetBtn.addEventListener("click", () => {
          const defaults = {};
          themeConfig.forEach((item) => { defaults[item.key] = item.default; });
          fillThemeInputs(defaults);
          applyVars(defaults);
          localStorage.setItem(STORAGE_KEY, JSON.stringify(defaults));
          status.textContent = "Theme reset to Catppuccin.";
        });

        toggleBtn.addEventListener("click", () => {
          const isHidden = panel.hasAttribute("hidden");
          if (isHidden) {
            panel.removeAttribute("hidden");
            toggleBtn.setAttribute("aria-expanded", "true");
          } else {
            panel.setAttribute("hidden", "");
            toggleBtn.setAttribute("aria-expanded", "false");
          }
        });

        const applyGiphyFallbacks = () => {
          const apiKey = (document.querySelector('meta[name="giphy-api-key"]')?.content || "").trim();
          if (!apiKey) return;

          const readGifCache = () => {
            try {
              const raw = localStorage.getItem(GIPHY_CACHE_KEY);
              const parsed = raw ? JSON.parse(raw) : {};
              return parsed && typeof parsed === "object" ? parsed : {};
            } catch (_) {
              return {};
            }
          };

          const writeGifCache = (cache) => {
            try {
              localStorage.setItem(GIPHY_CACHE_KEY, JSON.stringify(cache));
            } catch (_) {}
          };

          const cache = readGifCache();
          const now = Date.now();
          Object.keys(cache).forEach((key) => {
            const item = cache[key];
            if (!item || !item.url || !item.fetchedAt || (now - item.fetchedAt) > GIPHY_CACHE_TTL_MS) {
              delete cache[key];
            }
          });
          writeGifCache(cache);

          if (!giphyFetchFactoryPromise) {
            giphyFetchFactoryPromise = import("@giphy/js-fetch-api")
              .then((mod) => mod.GiphyFetch)
              .catch(() => null);
          }

          const targets = document.querySelectorAll("img[data-giphy-query]");
          targets.forEach((img) => {
            if (img.dataset.giphyBound === "1") return;
            img.dataset.giphyBound = "1";

            const query = img.dataset.giphyQuery || "shrug";
            const cacheKey = img.dataset.giphyCacheKey || `query:${query}`;
            const offset = Math.floor(Math.random() * 50);
            const showImageIfLoadable = (target, url) => new Promise((resolve) => {
              const probe = new Image();
              probe.onload = () => {
                target.src = url;
                target.hidden = false;
                resolve(true);
              };
              probe.onerror = () => resolve(false);
              probe.src = url;
            });

            const applyGifFromData = (items) => {
              if (!Array.isArray(items) || items.length === 0) return;
              const pick = items[Math.floor(Math.random() * items.length)];
              const fallbackSrc =
                pick?.images?.downsized_large?.url ||
                pick?.images?.downsized_medium?.url ||
                pick?.images?.original?.url;
              if (!fallbackSrc) return;
              showImageIfLoadable(img, fallbackSrc).then((ok) => {
                if (!ok) return;
                cache[cacheKey] = { url: fallbackSrc, fetchedAt: Date.now() };
                writeGifCache(cache);
              });
            };

            const fetchAndApply = () => {
              giphyFetchFactoryPromise
                .then((GiphyFetch) => {
                  if (!GiphyFetch) throw new Error("giphy-sdk-load-failed");
                  const gf = new GiphyFetch(apiKey);
                  return gf.search(query, { limit: 25, offset, rating: "pg-13", lang: "en" });
                })
                .then((res) => {
                  applyGifFromData(res?.data);
                })
                .catch(() => {
                  const url = `https://api.giphy.com/v1/gifs/search?api_key=${encodeURIComponent(apiKey)}&q=${encodeURIComponent(query)}&limit=25&offset=${offset}&rating=pg-13&lang=en`;
                  fetch(url)
                    .then((res) => (res.ok ? res.json() : Promise.reject(new Error("giphy-request-failed"))))
                    .then((data) => applyGifFromData(data?.data))
                    .catch(() => {});
                });
            };

            const cached = cache[cacheKey];
            if (cached?.url) {
              showImageIfLoadable(img, cached.url).then((ok) => {
                if (ok) return;
                delete cache[cacheKey];
                writeGifCache(cache);
                fetchAndApply();
              });
            } else {
              fetchAndApply();
            }
          });
        };

        applyGiphyFallbacks();
        document.addEventListener("turbo:load", applyGiphyFallbacks);
      })();
    </script>
  </body>
</html>
